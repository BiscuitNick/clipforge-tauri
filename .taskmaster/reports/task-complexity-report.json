{
	"meta": {
		"generatedAt": "2025-10-30T15:52:04.895Z",
		"tasksAnalyzed": 10,
		"totalTasks": 22,
		"analysisCount": 10,
		"thresholdScore": 5,
		"projectName": "Taskmaster",
		"usedResearch": true
	},
	"complexityAnalysis": [
		{
			"taskId": 13,
			"taskTitle": "Create Swift ScreenCaptureKit bridge module",
			"complexityScore": 9,
			"recommendedSubtasks": 8,
			"expansionPrompt": "Break down into: 1) Swift file creation and basic ScreenCaptureKit imports, 2) SCStreamDelegate protocol implementation, 3) SCStreamOutput protocol implementation, 4) SCStreamConfiguration setup with video settings, 5) SCContentFilter implementation for display/window filtering, 6) Start/stop/pause method implementation with error handling, 7) @objc annotation setup for C/Objective-C exposure, 8) CMSampleBuffer processing and CVPixelBuffer extraction with memory management.",
			"reasoning": "This task requires deep Apple framework knowledge, complex Swift-to-C interop, memory management, and working with underdocumented ScreenCaptureKit APIs. The codebase currently has no Swift code, requiring a completely new build pipeline setup."
		},
		{
			"taskId": 14,
			"taskTitle": "Build Rust FFI bridge for Swift interop",
			"complexityScore": 9,
			"recommendedSubtasks": 7,
			"expansionPrompt": "Break down into: 1) Create src-tauri/src/capture/ffi.rs module structure, 2) Implement extern 'C' functions matching Swift @objc exports, 3) Set up objc and block crates for Objective-C runtime handling, 4) Implement thread-safe frame queue using Arc<Mutex<VecDeque<Frame>>>, 5) Create CVPixelBuffer to Rust Vec<u8> conversion, 6) Handle Swift object lifecycle with proper retain/release using objc::rc::StrongPtr, 7) Add build.rs configuration to compile and link Swift code.",
			"reasoning": "FFI between Swift and Rust is notoriously complex, involving unsafe code, memory management across language boundaries, and thread safety concerns. The current codebase has objc crate experience but no Swift FFI."
		},
		{
			"taskId": 15,
			"taskTitle": "Replace screen enumeration with SCShareableContent",
			"complexityScore": 7,
			"recommendedSubtasks": 6,
			"expansionPrompt": "Break down into: 1) Replace NSScreen API calls with SCShareableContent.getShareableContent(), 2) Map SCDisplay objects to existing ScreenSource structure, 3) Extract window metadata from SCWindow objects, 4) Implement thumbnail generation using SCScreenshotManager, 5) Handle async nature with tokio::task::spawn_blocking, 6) Implement content caching with TTL for performance optimization.",
			"reasoning": "Moderate complexity due to API migration and async handling. The existing screen_sources/macos.rs has good patterns to build upon, but requires careful mapping to maintain compatibility."
		},
		{
			"taskId": 16,
			"taskTitle": "Implement frame processing and preview pipeline",
			"complexityScore": 8,
			"recommendedSubtasks": 7,
			"expansionPrompt": "Break down into: 1) Extract pixel data from CMSampleBuffer using CVPixelBufferGetBaseAddress, 2) Implement pixel format conversion from 420v/BGRA to RGB using Accelerate framework, 3) Create frame throttling mechanism (60fps to 15fps) using modulo counters, 4) Implement JPEG compression using image crate with configurable quality, 5) Add frame queue with size limits and overflow handling, 6) Include timestamp metadata using CMSampleBufferGetPresentationTimeStamp, 7) Create FrameProcessor trait with preview and encoding implementations.",
			"reasoning": "High complexity due to real-time performance requirements, image processing, and the need to balance quality vs performance. Requires careful memory management to prevent frame buffer bloat."
		},
		{
			"taskId": 17,
			"taskTitle": "Integrate Tauri event system for preview frames",
			"complexityScore": 6,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Break down into: 1) Define PreviewFrame event payload struct with base64 image data and metadata, 2) Implement event emission using app_handle.emit(), 3) Add preview control commands (start_preview, stop_preview), 4) Implement backpressure detection and frame dropping strategy, 5) Add performance metrics and debouncing using tokio::time::interval.",
			"reasoning": "Moderate complexity leveraging existing Tauri event patterns in the codebase. Main challenges are backpressure handling and performance optimization."
		},
		{
			"taskId": 18,
			"taskTitle": "Build React preview component for real-time display",
			"complexityScore": 6,
			"recommendedSubtasks": 6,
			"expansionPrompt": "Break down into: 1) Create PreviewWindow.tsx component with Tauri event listener, 2) Implement base64 to image conversion and Canvas API display, 3) Add double buffering using two canvas elements, 4) Style as floating overlay with drag handle and resize corners, 5) Implement show/hide toggle with CSS transitions, 6) Add FPS counter and recording indicator overlay with performance optimizations.",
			"reasoning": "Moderate complexity frontend work. The codebase already has React components and Tauri event handling patterns to build upon. Main challenges are smooth real-time rendering and UI performance."
		},
		{
			"taskId": 19,
			"taskTitle": "Configure FFmpeg stdin pipeline for raw frames",
			"complexityScore": 7,
			"recommendedSubtasks": 6,
			"expansionPrompt": "Break down into: 1) Modify screen_capture.rs to build FFmpeg command with -f rawvideo input parameters, 2) Set input parameters (-video_size, -framerate, -i pipe:0), 3) Implement frame writer that pipes raw frames to FFmpeg stdin, 4) Handle stdin write errors and EPIPE for FFmpeg termination, 5) Add frame timing using tokio::time::interval for consistent frame rate, 6) Support variable frame rate mode and real-time encoding flag.",
			"reasoning": "Moderately complex due to need to modify existing FFmpeg integration and handle stdin piping. Current screen_capture.rs provides good foundation but requires significant changes to support raw frame input."
		},
		{
			"taskId": 20,
			"taskTitle": "Implement audio capture via ScreenCaptureKit",
			"complexityScore": 7,
			"recommendedSubtasks": 6,
			"expansionPrompt": "Break down into: 1) Configure SCStreamConfiguration with capturesAudio = true, 2) Add microphone capture using addStreamOutput with audio type, 3) Extract audio samples from CMSampleBuffer in audio callback, 4) Convert audio format from Core Audio to raw PCM for FFmpeg, 5) Implement audio-video synchronization using presentation timestamps, 6) Create separate audio pipe to FFmpeg and support audio device selection.",
			"reasoning": "Moderately complex audio handling requiring sync with video pipeline. Current codebase has audio support in FFmpeg commands but no ScreenCaptureKit audio experience."
		},
		{
			"taskId": 21,
			"taskTitle": "Implement recording controls and state management",
			"complexityScore": 6,
			"recommendedSubtasks": 5,
			"expansionPrompt": "Break down into: 1) Implement pause using SCStream.stopCapture() while maintaining configuration, 2) Add resume with SCStream.startCapture() from paused state, 3) Update RecordingState to track paused duration for accurate timestamps, 4) Modify FFmpeg pipeline to handle discontinuous timestamps during pause, 5) Add state validation to prevent invalid transitions and handle system sleep/wake events.",
			"reasoning": "Moderate complexity building on existing recording state management. Current recording/mod.rs has good state handling patterns but needs extension for ScreenCaptureKit pause/resume."
		},
		{
			"taskId": 22,
			"taskTitle": "Add comprehensive testing and performance validation",
			"complexityScore": 5,
			"recommendedSubtasks": 4,
			"expansionPrompt": "Break down into: 1) Create integration tests using XCTest for Swift components and Rust tests for FFI layer, 2) Implement performance benchmarks comparing with current FFmpeg-only approach, 3) Create stress tests for memory usage over long sessions and high resolution recording, 4) Create CI pipeline tests for macOS compatibility and automated permission flow testing.",
			"reasoning": "Lower complexity testing and validation work. The task is comprehensive but follows standard testing patterns. Main challenge is setting up XCTest integration with the Rust build system."
		}
	]
}